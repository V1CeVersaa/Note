# EVERYTHING begins with C

内联函数在16章介绍，但是需要写在第6章

# Chapter 0

## 0.1 初衷

这个笔记建立的初衷是帮助笔者深刻记忆C语言的语法和特性，也作为加深对C语言的理解的工具（似乎终极目的就是提升程算分数编程能力）使用。

C语言因为其比较贴近底层，语法精简而高效，扩展性和可移植性强而闻名，因而作为计算机专业学生的第一门语言存在。另外，笔者在学习完C后，学习Python的过程极其愉悦（）

## 0.2 规划

# Chapter 1 数据类型和数据结构

# Chapter 2 分支与循环

# Chapter 3 函数

# Chapter 4 数组和指针

**神坑**：变长数组不能通过`int a[n] = {0};`的方式初始化

# Chapter 5 字符串和字符串函数

## 5.1 表示字符串和字符串I/O

字符串其实是以空字符`\0`结尾的`char`类型数组，因此，我们可以像处理一般数组的方式处理字符串，比如：

```c
char words[81] = "I am a string in an array.";//定义字符串words
words[8] = 'p';//将字符串的第9个字符改为'p'
const char* MSG = "This cannot be changed";//定义只读字符串MSG
```

如果要打印`MSG[22]`，则输出的是空字符，空字符不是空格，不会在输出窗口占用位置，只是标志字符串数组的结束。

我们一般用三种方法定义字符串：字符串常量、`char`类型数组、指向`char`类型的指针。被双引号括起来的内容被视为指向该字符串存储位置的指针，这类似于将数组名作为指向该数组的指针。比如以下程序：

```c
printf("%s,%p,%c","We","are","champions");
//Output: We,0x10000f61,c
```

我们对字符串用`%c%p`进行转换的时候，转换过去的其实是字符串第一个元素的地址和其对应的字符

数组形式的字符串（如`char arr1[] = "III"` ）在计算机的内存中分配一个内含4个元素的数组，每个元素作为一个字符，且最后一个元素为空字符。先将字符串常量存储在静态存储区中，程序开始运行之后为数组分配内存，初始化数组将静态存储区的字符串拷贝到数组中，编译器将数组名`arr1`作为该数组首元素地址的别名，而且作为地址常量，不能被改变。

一般来说，指针形式的定义一般于字符串字面量一起使用，被双引号括起来的内容是字符串字面量，而且被视为字符串的地址。指针形式（如`char *pt1 = "III"`*）*让编译器在静态存储区中分配4个元素的空间，开始运行程序时，编译器为指针变量（`*pt1`）留出一个存储位置，该变量最初指向该字符串的首字母，但是它的值可以被改变，即可以使用递增运算符。

由于指针形式字符串的存储形式，一般建议将指针初始化为字符串自变量时使用`const` 限定符。

编译器可以使用内存中的一个副本来表示所有完全相同的字符串字面量，所以下面程序打印出来的都是`"Jey"`

```c
char *p1 = "Hey";
p1[0] = 'J';
printf("Hey");
printf("%s","Hey");
```

由于数组名是一个指针变量，所以不能用`str1 = str2` 来简单地拷贝数组，这样只会让两个指针指向相同的内存区域。

我们可以定义字符串数组，也就是通过数组下标来访问不多个不同的字符串，有两种方式：使用存储字符串指针的数组或者多维数组：

```c
 const char* strarr1[3] = {
		"Hello",
		"Pardon",
		"Excuse me";
};
char straa2[3][10] = {
		"Hello",
		"Pardon",
		"Excuse me";
};
```

这两种方式最后实现的效果是几乎一样的，都代表着五个字符串，只使用一个下标时只代表一个字符串。比如`strarr1[0]`和`strarr2[0]`都代表着字符串 `"Hello"`

一般来说对数组的操作都是依赖于指针进行的。

## 5.2 字符串输入和输出

### 5.2.1 分配空间

最简单的分配空间的方式就是在 stack 上建立数组变量，而且还只能如此建立

```c
char name[81];
scanf("%s",name);
```

再就是利用C库函数`malloc()`分配内存，比如`char *name = (char *) malloc (sizeof(char)*8)`这样就可以按照数组形式的字符串来使用字符串了

### 5.2.2 危险的`gets()`函数

C11标准中，废弃了不安全的`gets()`函数，但是大多数编译器为了兼容性，仍然保留`gets()`函数。

`gets()`函数读取一整行输入，直到遇到换行符，然后丢弃换行符，存储其余字符在传递进来的字符串指针指向的地址上，并在字符的末尾添加一个空字符，使其成为字符串。比如：

```c
int strl = 10;
char words[strl];
puts("Enter a string please.");
gets(words);
puts(words):
```

`puts()`函数经常和`gets()`函数一起使用，这个函数用于显示字符串，并且在字符串的末尾添加换行符。

使用`gets()`函数时，`gets()`函数只知道数组的开始处，而不会检查数组的长度和字符串的长度是否相融洽。如果输入的字符串过长，超出了数组的存储范围，就会造成缓冲区溢出（buffer overflow），读取的数据将一直向后存储，覆盖掉后边内存上的内容，如果这些多余的字符只是占用了未被使用的内存，就不会立刻出现问题，而如果擦写掉了程序中的其余内存，这样就会让程序异常终止，或者出现其他情况。

出现`fragmentation fault`的错误的时候，一般是程序试图访问某些未被分配的内存。

### 5.2.3 `gets()`的替代品

- **`fgets()`和`fputs()`函数**

  `fgets()`函数接受三个参数：字符串存储的位置、读入字符的最大数量和要输入的文件。

  这里指出文件写入的一件事情，随着数据（可以时字符也可以是二进制文件）的写入，字符串存储位置（也就是接受的第一个指针参数）也会随之变化：往后移动一个单位。

  `fgets()`函数接受的第二个参数时读入数组的最大数量，如果该参数的值是`n`那么`fgets()`将读入`n-1`个字符，并且在最后加上一个空字符，或者读到第一个换行符号为止。

  `fgets()`函数的第三个参数指明要读入的文件，如果是从键盘读入数据，那么以`stdin`作为参数，或者输入文件指针。

  当输入行不溢出的时候，`fgets()`函数将换行符放在结尾，这与`fputs()`函数的特性相仿：这个函数在打印字符串的时候不会在最后加上换行符。可是如果使用`puts()`函数一起使用，那么可能就会发现出现了两个换行。

  `fputs()`函数接受两个参数：第一个指出要写入的字符串的位置，第二个指出目标写入的位置，如果输出到屏幕上，那么输入`stdout`作为参数。

  `fgets()`返回指向`char`的指针，如果一切顺利，函数返回的地址和传入的第一个参数相同，如果传到文件的结尾，将返回一个特殊的指针：空指针（null pointer），这个指针不会指向有效的数据，所以可以用来标识特殊情况。在代码钟可以用数字`0`来代替，但是C利用宏`NULL`来代替。下面是一个很有意思的例子：

  ```c
  char words[10];
  while(fgets(words,10,stdin) != NULL && words[0]!='\\n')
  {
  	fputs(words,stdout);
  }
  
  //Input :By the way,it returns a NULL pointer.
  //Output:By the way,it returns a NULL pointer.
  ```

  这个程序的实际操作过程是：首先`fgets()`函数读入9个字符，在后边加入`\\0`之后交给`fputs()`函数输出，但是此时不输出换行符，接着进入下一轮迭代，`fgets()`函数继续读入字符、交给`fputs()`函数输出……

- **`gets_s()`函数**

- **`s_gets()`函数**

  我们可以利用`fgets()`函数自行创建一个读取整行输入，并且利用空字符取代换行符、或者读取一部分字符，丢弃溢出的字符（其余部分的字符）的函数：

  ```c
  char * s_gets(char *st,int n)
  {
  	char *ret_val;
  	int i = 0;
  
      ret_val = fgets(st,n,stdin);
  	if(ret_val!=NULL)
  	{
  		while(st[i] != '\n' && st[i] != '\0')
      	{
  			i++;
  		}
  		if(st[i] == '\n')
  		{
  			st[i] = '\0';
  		}
  		else
  		{
  			while(getchar()!='\n')
  			{
  				continue;
  			}
  		}
  	}
  	return ret_val;
  }
  ```

  利用字符串函数，我们可以对函数进行修改，让它更加简洁。

  ``````c
  char *s_gets(char *st, int n)
  {
      char *ret_val;
      char *find;
      
      ret_val = fgets(st, n, stdin);
      if(ret_val)
      {
          find = strchr(st, 'n');
          if(find)
          	*find = '\0';
          else
              while(getchar() != '\n')
                  continue;
      }
      return ret_val;
  }
  ``````

  如果`fgets()`函数返回`NULL`，则证明读到文件结尾或者读取错误，`s_gets()`函数跳过了这个过程。

  我们丢弃多余的字符的原因是：这些多余的字符都存储于缓冲区之中，如果我们下一个要读取的数据是`double`类型的，那么就可能造成程序崩溃（因为输入了`char`类型甚至`char*`类型的数据），丢弃剩余行的数据可以令读取语句和键盘输入同步。

  这个函数并不完美，因为它在遇到不合适的输入的时候毫无反应，并且丢弃多余的字符的时候，不会告诉程序也不会告诉用户。但是至少会比`gets()`函数安全的多;-)。

- **`scanf()`函数**

  `scanf()`函数和`%s`转换说明可以读取字符串，但是`scanf()`函数在读取到空白字符（包括空格、换行符和空字符）的时候会终止对字符串的读取。`scanf()`函数还有另外一种确定输入结束的方法，也就是指定字符宽度，比如`%5d`，那么`scanf()`将在读取完五个字符或者读取到第一个空白字符后停止。

### 5.2.4 字符串输出

1. 在输出字符串的时候，我们必须确定字符串末尾有指示终止的空字符，下面就是一个**错误**的例子：`char words[]={'H','e','y','!'};`

   由于这个字符数组（不是字符串！）结尾并未有空字符，所以`words`不是字符串，如果我们使用这样的代码：`put(words)`，`puts()`函数由于未识别到空字符，就会一直向下读取、输出后续内存中的内容，这或许是 garbage value ，直到读到内存中的空字符（内存中还是有不少空字符的）。

2. `puts()`函数很容易使用，只需要传入需要输出的字符串的地址就可以了，它在输出的时候会在后边加上一个换行符。但是`puts()`函数的返回值众说纷纭：某些编译器返回的是输出的字符的个数，某些编译器输出的是输出的最后一个字符，有的干脆就返回一个非零的整数。

3. `fputs()`函数需要接受两个参数，一个是字符串的地址，另一个是写入的地址：这一般是文件指针，如果需要输出到屏幕上，传入`stdout`则可。这个函数的特点在于不会输出换行符。

4. `printf()`函数需要转换说明，它的形式更复杂些，需要输入更多的代码，计算机执行的时间会更长，但是优点在于可以更容易地输出更复杂、更多的字符串。

### 5.2.5 自定义输入输出函数

## 5.3 字符串函数

1. **`strlen()`函数**

   `strlen()`函数的实现其实很简单，我们写一个`while`循环就好了()，`strlen()`函数接受字符串地址，返回一个`unsigned int`的值来表示字符串的长度。

   重要的是我们可以利用`strlen()`函数来得到字符串的一些性质参数，进而更容易实现对字符串的操作，比如我们可以利用下面自行设计的函数来实现字符串的截断：

   ```c
   char *vit(char str[],unsigned int point)
   {
   	unsigned int length = strlen(str);
   	if(point >　length - 1)
   	{
   		return str;
   	}
   	else
   	{
   		str[point]='\\0';
   		return str;
   	}	
    //或者：if(strlen(str)>point)
    //		{
    // 		str[point] = '\\0';
    // 	}
   ```

2. **`strcat()`函数**

   `strcat()`函数接受两个字符串作为参数，用于将两个字符串拼接在一起，更确切地说是将第二个字符串的拷贝附加在第一个字符串的末尾，并且将拼接后的字符串作为第一个字符串，第二个字符串不变。`strcat()`函数返回第一个参数。

   `strcat()`函数和`gets()`函数一样，如果使用不当，也会导致缓冲区溢出。但是`gets()`函数被废弃的原因在于无法控制用户向程序里边输入什么，但是程序员是可以控制程序干什么的。因此，在经历输入的检查之后，我们认为至少程序是比较安全的，而使用`strcat()`函数不当导致缓冲区溢出的情况，被认为是程序员粗心导致的，而C语言相信程序员，程序员也有责任确保`strcat()`函数的使用安全。

3. **`strncat()`函数**

   为了避免`strcat()`函数左右的不安全的可能，我们类似`fputs()`函数那样，添加第二个参数，确定最大添加字符数，这就是`strncat()`函数的逻辑。

   `strncat()`函数接受三个参数，两个字符串指针和最大添加字符量，在加到最大字符量或者遇到空字符的时候停止。

   配合`strlen()`函数，`strncat()`函数可以很好用。

4. **`strcmp()`函数和`strncmp()`函数**

   首先，我们比较两个字符串的时候，比较的是字符串的内容，而不是字符串的地址，所以我们不能做判断指针是否相等的操作，而利用循环挨个判断还蛮复杂，这就是`strcmp()`函数诞生的逻辑。

   `strcmp()`函数接受两个字符串指针参数，如果字符串内容完全相等（包括大小写），`strcmp()`函数就会返回0，否则返回非零值。

   在字符串内容不一样的时候，如果第一个字符串的字符在**ASCII**码在第二个字符串的之前，`strcmp()`返回负数，反之返回正数；在某些编译器中，会作更加复杂的操作，也就是返回两字符的**ASCII**码的差。

   `strcmp()`函数会一直比较字符是否相同，直到出现不同或者字符串结束，这样的比较方式显得就非常笨重，而`strncmp()`函数提供了一种更为灵活的选择：`strncmp()`函数接受的第三个整数参数指定了比较到第几个字符（这里从1开始计数 ;-) ）比如`strncmp(str1,"strings",7)`就指定只查找`strings`这七个字符。

5. **`strcpy()`函数和`strncpy()`函数**

   `strcpy()`函数

6. **`sprint()`函数**

7. **Others.**

   - **`strchr()`函数**

   - **`strrchr()`函数**

   - **`strstr()`函数**

   - **`atoi()`函数**

   - **Character Classification**

     **`isalpha()`函数**

     和`isalpha()`函数属于一类的函数还有

     **`tolower()`和`toupper()`函数**
   
     ***cppreference*** 上对这两个函数归类为 ***Character Manipulation*** 解释是：*converts a character to lowercase/uppercase.*

# Chapter 6 存储类别和内存管理

## 6.1 存储类别

### 6.1.1 总览

### 6.1.2 关键词

- 其实这种关键词叫做存储类别说明符。
- `static`关键词让变量具有内部链接，同时具有静态存储期。
- `extern`关键词让变量具有外部链接，同时具有静态存储期。

### 6.1.3 作用域

作用域描述程序中可以访问标识符的区域，包括：块作用域，函数作用域，函数原型作用域和文件作用域。

- **块**是用一对花括号括起来的代码区域，包含`for`循环、`while`循环、`do while`循环和`if`语句所控制的代码，就算这些代码没有被花括号括起来，这也算是一个块。定义在块中的变量具有**块作用域**（block scope），它的可见范围只是在块内，或者说从定义处到包含该定义的块的末尾。此外，函数的形式参数虽然在花括号表示的块之前，但还是具有块作用域。只有在块内的语句才能访问具有块定义域的变量。

- 函数作用域仅仅用于`goto`语句的标签，当这个标签首次出现在函数的内层时，作用域也延伸到整个函数。函数作用域有效防止了标签混乱的情况发生，当然更好的处理方式或许是干脆不用`goto`语句（）

- 函数原型作用域的作用范围时从形式参数定义处到函数原型声明结束。这表明编译器更多的关心形式参数的类型而不是形参名，而只有在变长数组中，形参名才更有用。

- 如果在函数的外边定义了一个变量，比如以下程序：

  ```c
  #include<stdio.h>
  int glb_val =1;
  int main(void)
  {
  	printf("%d",glb_val);
  }
  ```

  这里的变量`glb_val`就具有文件作用域，更确切地说，具有外部链接的文件作用域，我们也叫它为全局变量。

  **Tip:**这里的`glb_val`它的作用域是从定义处到文件结束。

### 6.1.4 翻译单元

某些我们认为的多个文件可能在编译器里边以单个文件的形式出现，比如C预处理器就将头文件里边的内容替换`#include`指令。所以，编译器将源代码文件和所有的头文件都看作是一个包含着信息的单独文件，这个文件被称为是**翻译单元（translation unit）。**

如果程序由多个源代码文件组成，那么这个程序也由多个翻译单元组成，每个翻译单元对应着一个源代码文件和它的头文件。

目前我们的程序还不进行多文件处理。

### 6.1.5 链接

C 文件有着三种链接属性：外部链接、内部链接和无连接。具有块作用域、函数作用域和函数原型作用域的变量都是无连接变量。具有文件作用域的变量可以是外部链接也可以是内部链接。具有内部链接的变量只能在一个翻译单元使用，而具有外部链接的变量能在多文件程序中使用。

使用`extern`关键词，或者直接在函数外边定义的变量都是具有外部链接的变量，而使用`static`关键词的变量是具有内部链接的变量。

### 6.1.6 存储期

**存储期（storage duration）**描述了通过这些标识符访问的对象的生存期，某些变量存储期一过，它所占的内存就会被释放，相应的，存储的内容也会丢失。C对象有着四种存储期：静态存储期、自动存储期、线程存储期和动态分配存储期。

- 如果对象具有静态存储期，那么在程序的执行期间就会一直存在，内存不会被释放。关键词`extern`和`static`表明了对象的链接属性，而非存储期，但是它们都被自动分配静态存储期。
- 具有块作用域的变量一般具有自动存储期，当程序进入这些变量的块的时候时，为这些变量分配内存，当退出这个块的时候，就释放刚才分配的内存。值得注意的时，变长数组的存储期是声明处到块的末尾。
- 线程存储期用于并发程序设计
- 动态分配存储期

### 6.1.7 自动变量

声明在函数头、块内的变量属于自动存储类别的变量，具有自动存储期，块作用域且无连接。我们可以在C中使用关键词`auto`来表明这个变量的存储类型是自动变量。

### 6.1.8 寄存器变量

### 6.1.9 块作用域的静态变量

我们可以创建具有块作用域、无连接的静态变量，只需要在块中（这样就提供块作用域和无连接了）用存储类别说明符`static`（提供静态存储期）说明这个变量就可以了。

编译器在程序的生命周期内保证静态变量的存在，静态变量只会在程序中被初始化一次，不会在离开和进入作用域时被销毁或者重置。这是因为静态变量和外部变量在程序被载入内存的时候已经执行完毕，所以在逐个步骤调试的时候会发现含有 `static`声明的变量不太像时程序中的变量 ;-)

### 6.1.10 外部链接和内部链接的静态变量

我们在文件之间共享全局变量的时候需要特别小心，可以使用以下两个策略：其一，遵循外部变量的常用规则，亦即在一个文件之中使用定义式声明，在另一个文件之中使用引用式说明（使用`extern`关键字）；其二，将需要共享的全局变量放在一个头文件之中，在其他文件中包含这个头文件就可以了，然而，这种处理方式需要我们在头文件中使用`static`关键词，如果我们不使用`static`关键词或者使用`extern`关键词，那么我们就在每一个文件之中都包含了一个定义式声明，C标准是不允许这样子的。然而头文件实际上是给每一个文件提供了一个单独的数据副本，数据是重复的，浪费了很多的内存。

### 6.1.11 存储类别和函数

函数也有存储类别，可以是外部函数（默认）、静态函数或者内联函数。

- 使用`extern`关键词定义的函数是外部函数，是为了表明当前文件中使用的函数被定义在别处，除非使用`static`关键词，一般函数声明都默认为`extern`。
- 使用`static`关键词定义的函数是静态函数，静态函数只能用于其定义所在的文件。可以在其他文件中定义与之同名的函数，这样子就避免了名称冲突的问题。
- 内联函数：

## 6.2 随机数

## 6.3 动态分配内存

我们在前面所探讨的存储类别都有一个共同之处，在确定好存储类别之后，就只能根据确定好的内存存储规则，自动指定存储期和作用域。但是我们也可以利用库函数灵活分配和管理内存，只不过必须好好利用指针。

我们下面讨论**`malloc()`**、**`free()`**、**`calloc()`**和**`realloc()`**函数。

- `void* malloc(size_t size)`

  `malloc()`函数接受一个参数：所需要的内存字节数，之后它会找到合适的内存块，匿名分配`size`个`byte`大小的内存，返回动态分配内存块的首字节地址。如果无法分配内存，`malloc()`函数就会返回一个空指针。最早，由于`char`类型只占用一个字节，所以`malloc()`函数返回一个`char *`类型的指针，后来`malloc()`返回`void *`类型的通用指针，指向什么都可以，完全不需要考虑类型匹配的问题，但是为了增加代码的可读性，应该坚持强制类型转换。

  我们可以利用`malloc()`函数提供第三种声明数组的方式：将调用`malloc()`函数的返回值赋给指针，利用指针访问数组的元素，这样创建的其实是一个动态数组。比如：

  ```c
  double *ptd;
  ptd = (double *) malloc(30*sizeof(double));
  ```

  我们完全可以使用正常声明数组一样的方式访问这个数组`ptd`，比如`ptd[18]`。

  `malloc()`函数也可以声明多维数组，但是语法会复杂一些：

  ```c
  int numrow = 6,numcolumn = 5;
  int **array2 = (int **)malloc(sizeof(int*)*numrow);
  for(int i = 0; i<m; i++)
  {
  	array2[i] = (int *)malloc(sizeof(int)*numcolumn);
  }
  //或者
  int (* array)[numcolumn] = (int (* array)[numcolumn])malloc(sizeof(int)*numcolumn*numrow);
  ```

  先看第一种定义方式：在第二行创建了一个二级指针，也就是存储着指针的数组`array2`，在接下来的循环中，逐个为二维数组的每一行分配空间，同时将数组指针存储在`array2[i]`中。在读取元素`array2[1][2]`的时候，我们先读取出`array2[1]`，发现是个指针（其实是数组），然后读取这个数组的第三个元素（编号是2），这样就读出来了元素`array2[1][2]`。

  再看第二种定义方式：简而言之，等号左侧定义了一个指针变量`array`，指向的是`int[numcolumn]`类型的指针，说白了`array`也是一个二级指针。如果还要整花活，我们发现`*(*(array+1)+2)`和`array[1][2]`其实是一样的。换句话说，`array`指向一个内含6个整型的数组，因此`array[i]`表示一个由`numcolumn`个整数构成的元素，`array[i][j]`表明一个整数。

  其实二维数组是一块连续的内存，对于二维数组`array3[4][5]`它其实是一块**连续的内存**：我们完全可以按照5进制来理解这块内存的排布，五进制数 **ij** 表示的数所对应的内存上边的内容就是`array[i][j]`存储的内容。

- **`void free(void *ptr)`**

  `free()`函数接受先前被`malloc(),calloc(),realloc()`动态分配过的内存地址，之后将这些内存释放（deallocate），如果`free()`接受一个空指针，那么它什么都不会做。`free()`函数不返回任何值。如果`free()`函数接受的参数不是先前被`malloc(),calloc(),realloc()`分配过的内存地址，它的行为并未被定义。（*The behavior is undefined if the value of `ptr` does not equal a value returned earlier by `malloc(),calloc(),realloc()`*）我们也不能释放同一内存两次（*The behavior is undefined if the memory area referred to by `ptr` has already been deallocated, that is, `free()`, `free_sized()`, `free_aligned_sized()` (since C23), or `realloc()` has already been called with `ptr` as the argument and no calls to`malloc(), calloc(), realloc()` or `aligned_alloc()` (since C11) resulted in a pointer equal to `ptr` afterwards.*）。

### 6.4 ANSI C 类型限定符

值得注意的是，C99标准为限定符增加了一个新的属性：**幂等性**。也就是说可以在同一个声明之中使用多个相同的限定符，多余的限定符将被忽略。

### 6.4.1 `const`限定符

被`const`关键词声明的对象将成为只读变量，其值不能通过赋值、递增或递减等方式修改，但是至少初始化变量是没问题的，这样我们就只可以使用但不能修改对象的值了。

如果对指针使用`const`限定符，如果`const`限定符在`*`的前面，也就是`const int *num`或者`int const *num`，其实限定了指针指向的值为`const`，`num`指向了一个`int`类型的`const`值。如果`const`限定符在`*`的后面，也就是`int * const num`，则我们创建的指针本身的值不能改变，但是它指向的值可以改变。

更加常见的用法是声明为函数形参的指针。比如`void display(const int array[], int num)`，另外一个更熟悉的例子是字符串函数`void strcat(char * restrict string1,const char * restrict string2)`。 这使得传进去的数组的值没有被修改，这其实表明了`const`限定符实际提供了一种保护数据的方法。

我们同样可以对全局变量使用`const`限定符保护数据，因为`extern`限定符使得程序的任何一个部分都能使用并且改变这个变量，所以会平白无故产生许多危险，而`const`限定符让变量变成只读变量，这样就可以另程序更加安全。

### 6.4.2 `volatile`限定符

### 6.4.3 `restrict`限定符

# Chapter 7 文件处理

## 7.1 文件和文件类型

### 7.1.1 文件

文件其实是硬盘上的一段已经被命名的存储区域，C将文件看成一系列连续的字节，每一段字节都可以被单独读取。

### 7.1.2 文件模式

C提供两种文件模式：文本模式和二进制模式。

- 所有文件的内容都以二进制形式存储，但是如果文件最初使用二进制编码的字符表示文本，那么这个文件就是文本文件，其中包含文本内容。如果文件中的二进制值表示机器语言代码或者数值数据或者图片以及音乐编码，那么这个文件就是二进制文件，其中包含二进制内容。
- C提供了两种访问文件的途径：文本模式和二进制模式。在二进制模式之中，程序可以访问文件的每一个字节，而在文本模式之中，程序看见的内容和文件实际的内容不同，换行符会进行不同样式的映射转换。

## 7.2 基本的文件处理

### 7.2.1 标准文件和标准I/O

C程序会自动打开三个文件：标准输入、标准输出和标准错误输出。通常时候下，标准输入是普通的输入设备，一般是键盘；标准输出和标准错误输出都是系统的普通输出设备，一般是显示屏。函数`getchar()`、函数`printf()`和函数`puts()`都使用的是标准输出。标准错误输出提供了一个逻辑上不同的地方来显示错误输出，如果我们将输出发送给文件，那么发送到标准错误输出的内容仍然会被发送到屏幕上。

### 7.2.2 基本文件处理

- **`[[noreturn]] void exit(int exit_code)`**函数

  `exit()`函数关闭所有打开的文件并且结束程序，正如函数声明处所说

- **`File \*fopen(const char \*restrict filename, const char \*restrict mode)`函数**

  `fopen()`函数打开一个文件，其文件名由传入函数的第一个参数标识，返回文件指针。其需要的第二个参数是一个字符串，指定了待打开文件的模式。

  我们常见的打开文件模式有下面这些：

  - `"r"` 以只读模式打开文件；
  - `"w"` 以写模式打开文件，并且将现有文件的长度截为 0，如果文件不存在，则创建一个新文件；
  - `"a"` 以写模式打开文件，在现有文件结尾添加内容，若文件不存在，则创建一个新文件；
  - `"r+"` 以更新模式打开文件，亦即可以读写文件。

  如果打开文件失败，且不创建新文件，返回一个空指针

  值得注意的是，**文件指针并不指向任何实际文件，只是指向一个包含文件信息的数据对象**（换句话说是一个**结构**）其中包含了操作文件所用函数所需要的缓冲区信息。

- **`int fclose(FILE \*stream)`函数**

  `fclose()`函数关闭由`stream`给出的文件流，无论关闭是否成功，`stream`均与这个文件无关。*The behavior is undefined if the value of the pointer `stream` is used after `fclose` returns.*

  如果关闭成功，`fclose()`函数返回`0`，反之返回`EOF`。

- **`int fprintf(FILE *restrict stream, const char *restrict format, ...)`函数**

  `fprintf()`函数和`printf()`函数基本相同，只不过输出流从默认的`stdout`变成了需要自行给出的`stream`，亦即函数接受的第一个参数表示需要输出的位置。

- **`int fscanf(FILE *restrict stream,const char *restrict format, ...)`函数**

  这个函数和`scanf()`函数大差不差，只不过接受的第一个参数需要是待读取文件的文件指针。

- 

- 

- 

- 函数

- 函数

- 函数

- 

- **`size_t fread(void *restrict buffer, size_t size, size_t count, FILE * resrict stream)`**函数

  `fread()`函数接受的参数和`fwrite()`相同。在`fread()`函数之中，`buffer`是待读取文件数据在内存之中的地址，`stream`指定要读取的文件，该函数可以用于读取文件之中的数据，`size`代表着待读取数据每个元素的大小，`count`代表待读取项的项数。函数返回成功读取项的项数，一般是`count`，如果出现错误或者读到`EOF`，返回的值就会比`count`小。

  值得一提的是：*The file position indicator for the stream is advanced by the number of characters read.*

- **`size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream)`函数**

  `fwrite()`函数将缓冲数组`buffer`里面的`count`个元素写入到流`stream`之中。函数将需要写入的数据重新编译为`unsigned char`类型的数组，通过重复调用`fptc()`函数将其写入`stream`之中。和`fread()`函数相同，*The file position indicator for the stream is advanced by the number of characters read.*
  在实际使用`fread()`函数和`fwrite()`函数读写文件之中的数据时，用来标识位置的指针不断偏移，这使得我们不会重复读取数据，亦即可以实现这样的操作，这样子一个循环就能实现文件从头读到尾的操作：

  ```c
   while (fread(&buffer, sizeof(int16_t), 1, input))
  {
      buffer *= factor;
      fwrite(&buffer, sizeof(int16_t), 1, output);
  }
  ```

# Chapter 8 结构和其他数据形式



# Chapter 9 位操作

# C常用库

## `stdio`库

## `stdlib`库

### x.2.x 随机数

- `void srand(unsigned int seed)`

  `srand()`函数为伪随机数生成器`rand()`播种，正常的用法是：`srand((unsigned int) time(NULL))`

  这段代码利用当前时间为伪随机数生成器`rand(0)`提供种子，这样子就可以得到了近似于真随机的随机数。

- `int rand(void)`

  伪随机数生成器`rand()`生成一个介于`0`到`RAND_MAX`的随机数。如果没有`srand()`的播种，`rand()`函数就会默认生成种子为1的随机数。每次调用`rand()`函数，我们得到的都是上次生成的随机数的下一个数

  值得注意的是，在调用函数`rand()`之前的时候，伪随机数生成器只应该被播种一次*（Generally speaking, the pseudo-random number generator should only be seeded once, before any calls to `rand()`, and the start of the program. It should not be repeatedly seeded, or reseeded every time you wish to generate a new batch of pseudo-random numbers.）*。更重要的是，当`rand()`接受相同的种子的时候，他会生成相同的随机数数列。

## `time`库

### x.3.1 变量类型

- `time_t` 这是一个适合储存日历时间的**长整型`(long int)`**变量，表示着从**POSIX time** （1970年1月1日00：00）开始的总秒数。

### x.3.2 函数

- `time_t time(time_t *seconds)`

  `time()`函数将当前日历时间作为一个`time_t`类型的变量返回，并且将这个变量存储在输入的指针`seconds`中（前提是这个指针不为空指针）。

  由于`time_t`类型其实是一个`long int`转换成`int`(或者`unsigned int`)的时候还是需要强制转换说明的2
